[TOC]

# 动态窗口



## [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

### 题目描述

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

> 输入: "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:

> 输入: "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:

> 输入: "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

### 解题思路

**滑动窗口记录待选序列，并用hashmap辅助空间记录序列中元素，用来加速判断元素是否存在在序列中**。

```c++
class Solution
{
public:
    int lengthOfLongestSubstring(string s)
    {
        int left = 0;
        int right = 0;
        int lenSlice = 0;
        int maxLen = 0;
        unordered_map<char, int> slice;

        int len = s.length();
        if (len <= 1)
        {
            return len;
        }

        while(right < len)
        {
            char c = s[right];
            if (slice.find(c) != slice.end() && slice[c] >= left)
            {
                left = slice[c] + 1;
                lenSlice = right - left;
            }
            slice[c] = right;

            right++;
            lenSlice++;
            maxLen = max(lenSlice, maxLen);

        }
        return maxLen;
    }
};
```

## [最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

### 题目描述

给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。

示例：

> 输入: S = "ADOBECODEBANC", T = "ABC"
> 输出: "BANC"

说明：

- 如果 S 中不存这样的子串，则返回空字符串 ""。
- 如果 S 中存在这样的子串，我们保证它是唯一的答案。

### 解题思路

采用暴力法，遍历字符串，如果当前字符在目标字符串内，则以该位置建一个滑动窗口，在窗口内部检索，这种方法时间复杂度为O(N^2)，**超时！**

因此在滑动窗口时，要进行优化，如果当前窗口符合要求，则移动左边界寻找优化解，如果左边界移动导致窗口匹配失败，则移动右边界再次寻找新的匹配窗口。

**有一个小窍门：每次判断窗口是否匹配成功时，引入match次数，从而加快map对比速度。**

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        if (s.length() == 0 || t.length() > s.length()) {
            return "";
        }

        // 构建t字符串map，记录每个字母出现的次数
        unordered_map<char, int> charSetMap;
        for(int i = 0; i < t.length(); i++) {
            charSetMap[t[i]]++;
        }

        string res = "";
        int minLen = INT_MAX;
        int left, right;
        unordered_map<char, int> window;
        int match = 0;

        for (int i = 0; i < s.length(); i++) {
            if (charSetMap.find(s[i]) != charSetMap.end()) {
                left = i;
                right = left;
                break;
            }
        }

        while (right < s.length()) {
            if (charSetMap.find(s[right]) != charSetMap.end()) {
                window[s[right]]++;
                if (window[s[right]] == charSetMap[s[right]])
                    match++;
                while(match == charSetMap.size()) {
                    int len = right - left + 1;
                    if (minLen > len) {
                        res = s.substr(left, len);
                        minLen = len;
                    }
                    // 移动left
                    if(charSetMap.find(s[left]) != charSetMap.end() && --window[s[left]] < charSetMap[s[left]])
                        match--;
                    left++;
                }
            }
            right++;
        }

        return res;
    }
};
```



## [替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)

### 题目描述

给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。

注意:
字符串长度 和 k 不会超过 104。

示例 1:

> 输入:
> s = "ABAB", k = 2
>
> 输出:
>
> 解释:
> 用两个'A'替换为两个'B',反之亦然。

示例 2:

> 输入:
> s = "AABABBA", k = 1
>
> 输出:
> 4

### 解题思路

**滑动窗口，同时记录窗口内重复字符的最大次数，比较是否窗口需要滑动**

```c++
class Solution {
public:
    int characterReplacement(string s, int k) {
        vector<int> charSet(26, 0);
        int left = 0;
        int right = left;
        int len = s.length();
        int maxOccuerency = 0;  // 窗口内重复字符最大次数

        int res = 0;
        while (right < len) {
            charSet[s[right] - 'A']++;
            maxOccuerency = max(maxOccuerency, charSet[s[right] - 'A']); // 更新窗口内重复字符最大次数
            while(right - left + 1 - maxOccuerency > k){  // 窗口内，k次替换仍然无法满足，窗口左边界向右移
                charSet[s[left] - 'A']--;
                left++;
            }
            res = max(res, right - left + 1);
            right++;
        }
        return res;
    }
};
```



# 固定窗口

## [串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)

### 题目描述

给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。

注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。

 

示例 1：

> 输入：
>   s = "barfoothefoobarman",
>   words = ["foo","bar"]
> 输出：[0,9]
> 解释：
> 从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
> 输出的顺序不重要, [9,0] 也是有效答案。

示例 2：

> 输入：
>   s = "wordgoodgoodgoodbestword",
>   words = ["word","good","best","word"]
> 输出：[]

### 解题思路

最终匹配结果长度固定，限制固定大小的窗口，挨个匹配。

```c++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        if (words.size() == 0) {
            return {};
        }

        unordered_map<string, int> wordMap;
        for (auto& w : words) {
            wordMap[w]++;
        }

        int len = words[0].size();
        int windowSize = len * words.size();
        vector<int> res;

        for (int i = 0; i < s.size() - windowSize + 1; i++) {
            unordered_map<string, int> window;
            string sWindow = s.substr(i, windowSize);

            for (int j = 0; j < windowSize; j = j + len) {
                string target = sWindow.substr(j, len);

                if (wordMap.find(target) == wordMap.end())
                    break;
                
                window[target]++;

                if (window[target] > wordMap[target]) {
                    break;
                }
            }
            
            if (window == wordMap) {
                res.push_back(i);
            }
        }

        return res;
        
    }
};
```

## [滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

### 题目描述

给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

进阶：

你能在线性时间复杂度内解决此题吗？

示例:

> 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
> 输出: [3,3,5,5,6,7] 
> 解释: 
>
> 滑动窗口的位置                最大值

---------------               -----
> [1  3  -1] -3  5  3  6  7       3
>  1 [3  -1  -3] 5  3  6  7       3
>  1  3 [-1  -3  5] 3  6  7       5
>  1  3  -1 [-3  5  3] 6  7       5
>  1  3  -1  -3 [5  3  6] 7       6
>  1  3  -1  -3  5 [3  6  7]      7


提示：

> 1 <= nums.length <= 10^5
> -10^4 <= nums[i] <= 10^4
> 1 <= k <= nums.length



### 解题思路

**用双向链表记录窗口内数值，并且维护链表的降序关系：**

- 如果当前插入元素比首部大，则情况链表，将当前元素插入链表中 --> 因为窗口向右滑动，当前元素肯定是最大的，因此可以清空之前所有元素；
- 否则插入链表尾部：**注意插入时要保证链表的降序关系，把尾部比当前值小的元素从链表里删除**；
- 同时需要注意左边滑出来的元素，如果是首部，则删除链表首部；

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        if (1 == k) {
            return nums;
        }

        list<int> l;
        vector<int> res;

        int left = 0;
        int right = 0;
        // 初始化窗口
        while(right < k) {
            if (nums[right] > l.front()) {
                l.clear();  
            } else {
                // 保持队列有序
                while (nums[right] > l.back()) {
                    l.pop_back();
                }
            }
            l.push_back(nums[right]);
            right++;
        }
        res.push_back(l.front());

        while (right < nums.size()) {
            if (nums[left] == l.front()) {
                l.pop_front();
            }
            left++;

            if (nums[right] > l.front()) {
                l.clear();
            }else {
                while (nums[right] > l.back()) {
                    l.pop_back();
                }
            }
            l.push_back(nums[right]);
            right++;

            res.push_back(l.front());
        }

        return res;
    }
};
```

## [滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/)

### 题目描述

中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。

例如：

[2,3,4]，中位数是 3
[2,3]，中位数是 (2 + 3) / 2 = 2.5
给你一个数组 nums，有一个大小为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

 

示例：

给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。

> 窗口位置                      中位数

---------------               -----
> [1  3  -1] -3  5  3  6  7       1
>  1 [3  -1  -3] 5  3  6  7      -1
>  1  3 [-1  -3  5] 3  6  7      -1
>  1  3  -1 [-3  5  3] 6  7       3
>  1  3  -1  -3 [5  3  6] 7       5
>  1  3  -1  -3  5 [3  6  7]      6

 因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]。

### 解题思路

**多重结合Multiset+迭代器**

这种方法基于特定的语言，即 C++ 中的 multiset（多重集合）数据结构。

我们使用一个多重集合和一个迭代器（iterator），其中迭代器指向集合中的中位数。当我们添加或删除元素时，我们修改迭代器的指向，保证其仍然指向中位数。下面给出了我们的算法：

我们维护多重集合 window 的迭代器 mid；

首先我们在 window 中加入前 k 个元素，并让 mid 指向 window 中的第 \lfloor k/2 \rfloor⌊k/2⌋ 个元素（从 0 开始计数）；

当我们在 window 中加入数 num 时：

如果 num < *mid，那么我们需要将 mid 往前移；

如果 num >= mid，我们不需要对 mid 进行任何操作。

当我们在 windows 中删除数 num 时：

如果 num < *mid，我们需要将 mid 先往后移，再删除 num；

如果 num > *mid，我们不需要对 mid 进行任何操作；

如果 num == *mid，我们需要找到 num 第一次出现的位置对应的迭代器（使用 lower_bound()）并删除，而不是删除 mid 对应的数。随后和 num < *mid 的处理方式相同。

```c++
class Solution {
public:
    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
        vector<double> res;
        multiset<int> window(nums.begin(), nums.begin() + k);

        auto mid = next(window.begin(), k / 2);
        for (int i = k; ; i++) {
            res.push_back(((double)(*mid) + *next(mid, k % 2 - 1)) * 0.5);

            if (i == nums.size())
                break;

            window.insert(nums[i]);
            if (nums[i] < *mid)
                mid--;

            if (nums[i - k] <= *mid)
                mid++;

            window.erase(window.lower_bound(nums[i-k]));
        }

        return res;
    }
};
```

