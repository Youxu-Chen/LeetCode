[TOC]

# 动态窗口



## [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

### 题目描述

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

> 输入: "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:

> 输入: "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:

> 输入: "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

### 解题思路

**滑动窗口记录待选序列，并用hashmap辅助空间记录序列中元素，用来加速判断元素是否存在在序列中**。

```c++
class Solution
{
public:
    int lengthOfLongestSubstring(string s)
    {
        int left = 0;
        int right = 0;
        int lenSlice = 0;
        int maxLen = 0;
        unordered_map<char, int> slice;

        int len = s.length();
        if (len <= 1)
        {
            return len;
        }

        while(right < len)
        {
            char c = s[right];
            if (slice.find(c) != slice.end() && slice[c] >= left)
            {
                left = slice[c] + 1;
                lenSlice = right - left;
            }
            slice[c] = right;

            right++;
            lenSlice++;
            maxLen = max(lenSlice, maxLen);

        }
        return maxLen;
    }
};
```

# 固定窗口

## [串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)

### 题目描述

给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。

注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。

 

示例 1：

> 输入：
>   s = "barfoothefoobarman",
>   words = ["foo","bar"]
> 输出：[0,9]
> 解释：
> 从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
> 输出的顺序不重要, [9,0] 也是有效答案。

示例 2：

> 输入：
>   s = "wordgoodgoodgoodbestword",
>   words = ["word","good","best","word"]
> 输出：[]

### 解题思路

最终匹配结果长度固定，限制固定大小的窗口，挨个匹配。

```c++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        if (words.size() == 0) {
            return {};
        }

        unordered_map<string, int> wordMap;
        for (auto& w : words) {
            wordMap[w]++;
        }

        int len = words[0].size();
        int windowSize = len * words.size();
        vector<int> res;

        for (int i = 0; i < s.size() - windowSize + 1; i++) {
            unordered_map<string, int> window;
            string sWindow = s.substr(i, windowSize);

            for (int j = 0; j < windowSize; j = j + len) {
                string target = sWindow.substr(j, len);

                if (wordMap.find(target) == wordMap.end())
                    break;
                
                window[target]++;

                if (window[target] > wordMap[target]) {
                    break;
                }
            }
            
            if (window == wordMap) {
                res.push_back(i);
            }
        }

        return res;
        
    }
};
```



