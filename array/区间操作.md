[TOC]

# [合并区间](https://leetcode-cn.com/problems/merge-intervals/)

## 题目描述

给出一个区间的集合，请合并所有重叠的区间。

示例 1:

> 输入: [[1,3],[2,6],[8,10],[15,18]]
> 输出: [[1,6],[8,10],[15,18]]
> 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2:

> 输入: [[1,4],[4,5]]
> 输出: [[1,5]]
> 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

## 解题思路

遇到区间问题，第一反应就是先排个序，这里用到了go里面的`sort.Slice()`函数，支持二维切片排序。

排好序之后，遍历区间，用min和max表示当前区间的边界，通过与当前区间进行比较判断是否存在重叠（因为是排好序的，因此只需要与前一个区间比较即可），从而将重叠区间合并。

```go


func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }

   	// 二维切片排序 - 升序
    sort.Slice(intervals, func(i, j int) bool{
        return intervals[i][0] < intervals[j][0]
    })

  	// 挡圈区间边界
    min := intervals[0][0]
    max := intervals[0][1]
    count := 0

    for i := 1; i < len(intervals); i++ {

        if intervals[i][0] > max {
            // 当前区间与前一个区间不想交

            // 将上一个区间[min, max]区间添加到结果中
            intervals[count][0] = min
            intervals[count][1] = max
            count++

            // 更新min和max为当前区间的值
            min = intervals[i][0]
            max = intervals[i][1]
        } else if intervals[i][0] >= min {
            // 当前区间与前一个区间存在重叠

            // 判断右边界
            if intervals[i][1] > max {
                // 右边界超出范围
                max = intervals[i][1]
            } else {
                // 区间重叠
                continue
            }
        } else {
            // nothing， 不存在的情况
        }
    }

    // 保存最后一个区间
    intervals[count][0] = min
    intervals[count][1] = max

    return intervals[:count+1]
}
```

