[TOC]

# [合并区间](https://leetcode-cn.com/problems/merge-intervals/)

## 题目描述

给出一个区间的集合，请合并所有重叠的区间。

示例 1:

> 输入: [[1,3],[2,6],[8,10],[15,18]]
> 输出: [[1,6],[8,10],[15,18]]
> 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2:

> 输入: [[1,4],[4,5]]
> 输出: [[1,5]]
> 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

## 解题思路

遇到区间问题，第一反应就是先排个序，这里用到了go里面的`sort.Slice()`函数，支持二维切片排序。

排好序之后，遍历区间，用min和max表示当前区间的边界，通过与当前区间进行比较判断是否存在重叠（因为是排好序的，因此只需要与前一个区间比较即可），从而将重叠区间合并。

```go


func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }

   	// 二维切片排序 - 升序
    sort.Slice(intervals, func(i, j int) bool{
        return intervals[i][0] < intervals[j][0]
    })

  	// 挡圈区间边界
    min := intervals[0][0]
    max := intervals[0][1]
    count := 0

    for i := 1; i < len(intervals); i++ {

        if intervals[i][0] > max {
            // 当前区间与前一个区间不想交

            // 将上一个区间[min, max]区间添加到结果中
            intervals[count][0] = min
            intervals[count][1] = max
            count++

            // 更新min和max为当前区间的值
            min = intervals[i][0]
            max = intervals[i][1]
        } else if intervals[i][0] >= min {
            // 当前区间与前一个区间存在重叠

            // 判断右边界
            if intervals[i][1] > max {
                // 右边界超出范围
                max = intervals[i][1]
            } else {
                // 区间重叠
                continue
            }
        } else {
            // nothing， 不存在的情况
        }
    }

    // 保存最后一个区间
    intervals[count][0] = min
    intervals[count][1] = max

    return intervals[:count+1]
}
```

# [插入区间](https://leetcode-cn.com/problems/insert-interval/)

## 题目描述

给出一个无重叠的 ，按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

示例 1:

> 输入: intervals = [[1,3],[6,9]], newInterval = [2,5]
> 输出: [[1,5],[6,9]]

示例 2:

> 输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
> 输出: [[1,2],[3,10],[12,16]]
> 解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。

## 解题思路

1. 复用上述合并区间思想，将待插入区间添加到区间列表里，排序合并即可。

```go


func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }

    sort.Slice(intervals, func(i, j int) bool{
        return intervals[i][0] < intervals[j][0]
    })

    fmt.Print(intervals)

    min := intervals[0][0]
    max := intervals[0][1]
    count := 0

    for i := 1; i < len(intervals); i++ {

        if intervals[i][0] > max {
            // 当前区间与前一个区间不想交

            // 将上一个区间[min, max]区间添加到结果中
            intervals[count][0] = min
            intervals[count][1] = max
            count++

            // 更新min和max为当前区间的值
            min = intervals[i][0]
            max = intervals[i][1]
        } else if intervals[i][0] >= min {
            // 当前区间与前一个区间存在重叠

            // 判断右边界
            if intervals[i][1] > max {
                // 右边界超出范围
                max = intervals[i][1]
            } else {
                // 区间重叠
                continue
            }
        } else {
            // nothing， 不存在的情况
        }
    }

    // 保存最后一个区间
    intervals[count][0] = min
    intervals[count][1] = max

    return intervals[:count+1]
}

func insert(intervals [][]int, newInterval []int) [][]int {
    return merge(append(intervals, newInterval))
}
```

2. 贪心法：如果目标区间与当前区间不重叠，则插入即可；否则更新目标区间范围

> 遍历原数组，如果当前区间和新区间没有交集，则直接存入答案；
> 如果有交集，便和新区间合并，更新新区间的左右边界；
> 如果当前区间和新区间无交集且大于新区间，则新区间和后面所有的区间都可存入答案。



```go
func insert(intervals [][]int, newInterval []int) [][]int {
    // 返回结果
    var res [][]int

    // 标记目标区间是否添加了
    visit := false

    for i := range intervals {
        // 当前区间无重叠
        if newInterval[0] > intervals[i][1] {
            res = append(res, intervals[i])
            continue
        } else if newInterval[1] < intervals[i][0] {
            // 目标区间在左边，则插入目标区间，然后依次插入后续所有区间，结束
            res = append(res, newInterval)
            visit = true
            for j := i; j < len(intervals); j++ {
                res = append(res, intervals[j])
            }
            break
        } else {
            // 区间有重叠，则更新目标区间范围
            // 注意这里是更新目标区间范围，因此后续比较只需要和目标区间比较即可
            newInterval[0] = min(newInterval[0], intervals[i][0])
            newInterval[1] = max(newInterval[1], intervals[i][1])
        }
    }

    // 如果目标区间在最右边，则visit为false，则添加即可
    if !visit {
        res = append(res, newInterval)
    }

    return res
}

func max(i, j int) int {
    if i > j {
        return i
    } else {
        return j
    }
}

func min(i, j int) int {
    if i > j {
        return j
    } else {
        return i
    }
}
```

