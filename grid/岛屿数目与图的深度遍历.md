[TOC]

# [岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

## 题目描述

给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。

示例 1:

> 输入:
> 11110
> 11010
> 11000
> 00000
>
> 输出: 1

示例 2:

> 输入:
> 11000
> 11000
> 00100
> 00011
>
> 输出: 3

## 解题思路

从当前岛屿出发，遍历其可达的所有位置（值为1的位置），并将其标记为0，以使得岛屿不重复计数；然后深度遍历整个图统计所有1的数目即可。

```go
func numIslands(grid [][]byte) int {
    res := 0
    for i := 0; i < len(grid); i++ {
        for j := 0; j < len(grid[i]); j++ {
            // 如果当前位置为1，则表示是岛屿
            if grid[i][j] == '1' {
                res++

                // 深度遍历当前位置可达的所有区域，并将其标记为0，后续遍历时则不会重复技术
                dfs(grid, i, j)
            }
        }
    }

    // 返回岛屿计数结果
    return res
}

// 深度遍历(x,y)可到达的所有陆地范围，并标记为0
func dfs(grid [][]byte, x,y int) {
    if x < 0 || x >= len(grid) || y < 0 || y >= len(grid[x]) || grid[x][y] == '0' {
        return
    }

    // 标记当前位置为0
    grid[x][y] = '0'

    // 上下左右四个方向分别进行标记

    // 上
    dfs(grid, x-1, y)

    // 下
    dfs(grid, x+1, y)

    // 左
    dfs(grid, x, y-1)

    // 右
    dfs(grid, x, y+1)

}
```

# 深度遍历

上下左右4个方向，每个方向一条路走到黑...

# 广度遍历

先遍历上下左右四个方向，然后再遍历每个方向的上下左右四个方向，遍历时可借助队列记录遍历先后顺序。