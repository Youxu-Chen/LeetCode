# [困于环中的机器人](https://leetcode-cn.com/problems/robot-bounded-in-circle/)

# 题目描述

在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。机器人可以接受下列三条指令之一：

"G"：直走 1 个单位
"L"：左转 90 度
"R"：右转 90 度
机器人按顺序执行指令 instructions，并一直重复它们。

只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。

示例 1：

> 输入："GGLLGG"
> 输出：true
> 解释：
> 机器人从 (0,0) 移动到 (0,2)，转 180 度，然后回到 (0,0)。
> 重复这些指令，机器人将保持在以原点为中心，2 为半径的环中进行移动。

示例 2：

>  输入："GG"
> 输出：false
> 解释：
> 机器人无限向北移动。

示例 3：

> 输入："GL"
输出：true
解释：
机器人按 (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ... 进行移动。

## 解题思路

一起来简化一下问题，一顿指令之后，位置从(0,0)到了(x,y)，其实可以把整个指令看成一步(0,0)->(x,y)
接下来第二次指令会怎么走呢，很简单，如果(x,y)等于(0,0)，那么相当于整体位移为0，自然是回去了，其余情况，保持第一轮操作位移的长度，方向有4种:
如果初始方向是向上，现在变成了向左，那么整体位移的方向向左偏转，就像例子里面的“GL”
如果现在变成向右，整体向右偏转，就像GR”
如果现在变成向下，整体旋转180度，就像“GRR”，直接下一次就走回去了，这三种情况，最后都能回去
而当现在方向变成向上，那么就保持位移方向不变，就像例子里面的“GG”一样，一去不复返
所以，总而言之，**一次指令之后，只有(x,y)不是原点，并且方向和原来的方向一致，最后才回不去**

```go
func isRobotBounded(instructions string) bool {
    // 方向：0上1右2下3左
    d := 0
    dx := []int{0,1,0,-1}
    dy := []int{1,0,-1,0}

    // 起点位置
    x := 0
    y := 0

    for i := 0; i < len(instructions); i++ {
        switch instructions[i] {
            case 'R':
                // 调整方向，例如 1 --> 2则表示右变成做
                d += 1
            case 'L':
                d += 3
            case 'G':
                d = d % 4
                x = x + dx[d]
                y = y + dy[d]
        }
    }

    return (x == 0 && y == 0) || (d % 4 != 0)
}
```

